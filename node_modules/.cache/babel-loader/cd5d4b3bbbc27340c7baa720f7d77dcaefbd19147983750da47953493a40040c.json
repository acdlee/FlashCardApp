{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/clsno/OneDrive/Desktop/Learn React/Flashcards/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/clsno/OneDrive/Desktop/Learn React/Flashcards/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _chapters = /*#__PURE__*/_classPrivateFieldLooseKey(\"chapters\");\nclass Deck {\n  // Chapters data\n\n  constructor() {\n    Object.defineProperty(this, _chapters, {\n      writable: true,\n      value: void 0\n    });\n    /**Class representation of a Deck.\r\n     * \r\n     * Functions:\r\n     * void addChapter(chapter_name)\r\n     * getChapter(chapter_name) -> Chapter()\r\n     * hasChapter(chapter_name) -> boolean\r\n     * getChapters() -> Array of Chapter objs\r\n     * void printDeck()\r\n     * getChapterNames() -> Array of strings\r\n     */\n    _classPrivateFieldLooseBase(this, _chapters)[_chapters] = {};\n  }\n  getChapterNames() {\n    /**Returns the names of all chapters within the deck.\r\n     * \r\n     * @returns Array of chapter name strings\r\n     */\n    let names = [];\n    for (const [name, _] of Object.entries(_classPrivateFieldLooseBase(this, _chapters)[_chapters])) {\n      names.push(name);\n    }\n    return names;\n  }\n  addChapter(chapter_name) {\n    /**Adds a Chapter object with name (reference string) chapter_name to the Deck.\r\n     * \r\n     * @param {string} chapter_name - the name (reference string) of the new Chapter object\r\n     * @returns nothing\r\n     */\n    if (chapter_name != '' && !this.hasChapter(chapter_name)) {\n      // empty and existence check\n      const new_chapter = new Chapter();\n      _classPrivateFieldLooseBase(this, _chapters)[_chapters][chapter_name] = new_chapter;\n    }\n  }\n  getChapter(chapter_name) {\n    /**Accessor for a Chapter object associated with 'chapter_name', within the Deck.\r\n     * \r\n     * @param {string} chapter_name - the name (reference string) of the desired Chapter object\r\n     * @returns Chapter object if found, undefined otherwise\r\n     */\n    if (chapter_name != '' && this.hasChapter(chapter_name)) {\n      // empty and existence check\n      return _classPrivateFieldLooseBase(this, _chapters)[_chapters][chapter_name];\n    }\n    return undefined;\n  }\n  getChapters() {\n    /**Accessor for all chapters within a deck.\r\n     * \r\n     * @returns An array of chapter objects.\r\n     */\n    let chapters_array = [];\n    for (const chapter in _classPrivateFieldLooseBase(this, _chapters)[_chapters]) {\n      chapters_array.push(chapter);\n    }\n    return chapters_array;\n  }\n  hasChapter(chapter_name) {\n    /**Checks if the Deck has a Chapter with associated name (reference string) chapter_name.\r\n     * \r\n     * @param {string} chapter_name - the name (reference string) of the Chapter in question\r\n     * @returns boolean\r\n     */\n    return _classPrivateFieldLooseBase(this, _chapters)[_chapters].hasOwnProperty(chapter_name);\n  }\n  printDeck() {\n    /**Prints the Deck for debugging.\r\n     * \r\n     */\n    console.log(\"__________\\nDeck:\");\n    for (const [_, chapter] of Object.entries(_classPrivateFieldLooseBase(this, _chapters)[_chapters])) {\n      console.log(\"\\t\\tChapter:\");\n      chapter.printCards();\n    }\n  }\n}\nvar _cards = /*#__PURE__*/_classPrivateFieldLooseKey(\"cards\");\nclass Chapter {\n  // Cards data\n\n  constructor() {\n    Object.defineProperty(this, _cards, {\n      writable: true,\n      value: void 0\n    });\n    /**Class representation of a Chapter.\r\n     * \r\n     * Functions:\r\n     * void addCard(question, answer)\r\n     * void editCard(id, new_question, new_answer)\r\n     * getCard(id) -> object\r\n     * void printCards()\r\n     */\n    _classPrivateFieldLooseBase(this, _cards)[_cards] = [];\n    this.id = 0;\n    this.size = 0;\n  }\n  addCard(question, answer) {\n    /**Adds an object representing a card with input args question and answer.\r\n     * The associated 'id' is handled internally.\r\n     * \r\n     * @param {string} question - the card question\r\n     * @param {string} answer - the card answer\r\n     * @returns nothing\r\n     */\n    // Remember to increment the id and size\n    _classPrivateFieldLooseBase(this, _cards)[_cards].push({\n      id: this.id++,\n      \"question\": question,\n      \"answer\": answer\n    });\n    this.size++;\n  }\n  editCard(id, new_question = undefined, new_answer = undefined) {\n    /**Edits the card object with id='id' to the new question and/or new answer.\r\n     * \r\n     * @param {int} id - id for the target card\r\n     * @param {string} question - new question\r\n     * @param {string} answer - new answer\r\n     */\n    if (id < this.id) {\n      // ensure the card exists\n      // Edit question\n      if (new_question) {\n        _classPrivateFieldLooseBase(this, _cards)[_cards][id][\"question\"] = new_question;\n      }\n      // Edit answer\n      if (new_answer) {\n        _classPrivateFieldLooseBase(this, _cards)[_cards][id][\"answer\"] = new_answer;\n      }\n    }\n  }\n  getCard(id) {\n    /**Accessor for the associated card with id='id'.\r\n     * \r\n     * @param {int} id - associated id for the desired card\r\n     * @returns object\r\n     */\n    if (id < this.id) {\n      // ensure the card exists\n      return _classPrivateFieldLooseBase(this, _cards)[_cards][id];\n    }\n  }\n  printCards() {\n    /**Prints the cards for debugging.\r\n     * \r\n     */\n    for (let i = 0; i < _classPrivateFieldLooseBase(this, _cards)[_cards].length; i++) {\n      console.log(_classPrivateFieldLooseBase(this, _cards)[_cards][i]);\n    }\n  }\n}\nvar _data = /*#__PURE__*/_classPrivateFieldLooseKey(\"data\");\nexport class DB {\n  // Flashcards data\n\n  constructor() {\n    Object.defineProperty(this, _data, {\n      writable: true,\n      value: void 0\n    });\n    /**Class representation of the database for the Flashcard App.\r\n     * \r\n     * Functions:\r\n     * void initData()\r\n     * void addCard(deck_name, chapter_name, card)\r\n     * void addChapter(deck_name, chapter_name)\r\n     * void addDeck(deck_name)\r\n     * hasDeck(deck_name) -> boolean\r\n     * hasChapter(deck_name, chapter_name) -> boolean\r\n     * getChapter(deck_name, chapter_name) -> Chapter obj\r\n     * void printDecks()\r\n     * getDeckNames() -> Array of strings\r\n     * getChapterNames(deck_name) -> Array of strings\r\n     * getCardIds(deck_name, chapter_name) -> Array of ints\r\n     */\n    this.dummy_data = {\n      \"Chapter 1\": [{\n        question: \"What is a training instance?\",\n        answer: \"One training iteration through all the data.\"\n      }, {\n        question: \"Why use machine learning?\",\n        answer: \"To accomplish tasks infeasible for a human.\"\n      }, {\n        question: \"What is machine learning?\",\n        answer: \"A computer being trained to improve at a task, by some performance measure.\"\n      }],\n      \"Chapter 2\": [{\n        question: \"What is 2+2?\",\n        answer: \"It's 4 silly!\"\n      }, {\n        question: \"What is the integral of x squared?\",\n        answer: \"x to the third, all divided by 3... + C!\"\n      }, {\n        question: \"Cats or dogs?\",\n        answer: \"Cats.\"\n      }]\n    };\n    this.initData();\n  }\n  initData() {\n    /**Initializes the data based off some dummy data.\r\n     * \r\n     */\n    _classPrivateFieldLooseBase(this, _data)[_data] = {};\n    const deck_name = \"Deck 0\";\n    this.addDeck(deck_name); // add the deck\n    for (const [chapter_name, chapter_cards] of Object.entries(this.dummy_data)) {\n      this.addChapter(deck_name, chapter_name);\n      for (let i = 0; i < chapter_cards.length; i++) {\n        this.addCard(deck_name, chapter_name, chapter_cards[i]);\n      }\n    }\n  }\n  getChapter(deck_name, chapter_name) {\n    /**Accessor for a chapter with name='chapter_name' in a deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck\r\n     * @param {string} chapter_name - Target chapter\r\n     * @return Chapter object\r\n     */\n    if (this.hasChapter(deck_name, chapter_name)) {\n      // existence check\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapter(chapter_name);\n    }\n  }\n  getDeckNames() {\n    /**Returns the deck names for all decks in the database.\r\n     * \r\n     * @returns Array of strings\r\n     */\n    const names = [];\n    for (const [deck_name, _] of Object.entries(_classPrivateFieldLooseBase(this, _data)[_data])) {\n      names.push(deck_name);\n    }\n    return names;\n  }\n  getChapterNames(deck_name) {\n    /**Returns the chapter names for a given deck.\r\n     * \r\n     * @param {string} deck_name - Target deck\r\n     * @returns Array of strings of chapter names\r\n     */\n    if (this.hasDeck(deck_name)) {\n      // existence check\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapterNames();\n    }\n    return undefined;\n  }\n  getChapters(deck_name) {\n    /**Accessor for chapters in a deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @return Array of chapter objects\r\n     */\n    if (this.hasDeck(deck_name)) {\n      // existence check\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapters();\n    }\n  }\n  addCard(deck_name, chapter_name, card) {\n    /**Adds a flashcard with values='card' to a chapter with name='chapter_name' to\r\n     * a deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - Target chapter name\r\n     * @param {object} card - New flashcard values\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name)) {\n      // empty and existence checks\n      _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapter(chapter_name).addCard(card[\"question\"], card[\"answer\"]);\n    }\n  }\n  addChapter(deck_name, chapter_name) {\n    /**Adds a chapter with name='chapter_name' to a deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - New chapter name\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name) == false) {\n      // empty and existence checks\n      // if the names aren't empty, the deck exists, and the chapter does not exist:\n      _classPrivateFieldLooseBase(this, _data)[_data][deck_name].addChapter(chapter_name);\n    }\n  }\n  addDeck(deck_name) {\n    /**Adds a deck to the data with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - New deck name\r\n     */\n    if (deck_name != '' && !this.hasDeck(deck_name)) {\n      // empty and existence check\n      _classPrivateFieldLooseBase(this, _data)[_data][deck_name] = new Deck();\n    }\n  }\n  hasDeck(deck_name) {\n    /**Checks if the data has the deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @returns boolean\r\n     */\n    return _classPrivateFieldLooseBase(this, _data)[_data].hasOwnProperty(deck_name);\n  }\n  getCardIds(deck_name, chapter_name) {\n    /**Returns the IDs of cards in chapter 'chapter_name' in deck 'deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck\r\n     * @param {string} chapter_name - Target chapter\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name)) {\n      // empty and existence checks\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapter(chapter_name).getCard(id);\n    }\n  }\n  hasChapter(deck_name, chapter_name) {\n    /**Checks if the data has the chapter with name='chapter_name' in deck\r\n     * with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - Target chapter name\r\n     * @returns boolean\r\n     */\n    if (this.hasDeck(deck_name)) {\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].hasChapter(chapter_name);\n    }\n    return false; // if the deck does not exist, return false\n  }\n  getCard(deck_name, chapter_name, id) {\n    /**Returns a flashcard with id='id' from a chapter with name='chapter_name' and\r\n     * deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - Target chapter name\r\n     * @param {int} card - Target card id\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name)) {\n      // empty and existence checks\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapter(chapter_name).getCard(id);\n    }\n  }\n  editCard(deck_name, chapter_name, id, question, answer) {\n    /**Edits a flashcard with id='id' from a chapter with name='chapter_name' and\r\n     * deck with name='deck_name', with new values question='question and answer='answer'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - Target chapter name\r\n     * @param {int} card - Target card id\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name)) {\n      // empty and existence checks\n      _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapter(chapter_name).editCard(id, question, answer);\n    }\n  }\n  printDecks() {\n    /**Prints each deck for debugging.\r\n     * \r\n     */\n    for (const [_, deck] of Object.entries(_classPrivateFieldLooseBase(this, _data)[_data])) {\n      deck.printDeck();\n    }\n  }\n}\nvar _db = /*#__PURE__*/_classPrivateFieldLooseKey(\"db\");\nclass TestDB {\n  constructor() {\n    /*Test Cases:\r\n    1. get a card's q/a\r\n    2. add a card\r\n    3. edit a card\r\n    4. add a chapter (dupe and unique chapter)\r\n    5. add a deck   (dupe and unique deck)\r\n    6. adding a new chapter and card to a new deck\r\n      Still need to test:\r\n    1. adding a card to a deck that doesn't exist\r\n    2. adding a card to a chapter that doesn't exist\r\n    3. editing a card that doesn't exist\r\n    */\n    Object.defineProperty(this, _db, {\n      writable: true,\n      value: void 0\n    });\n    /**Test class for the DB class.\r\n     * \r\n     */\n    _classPrivateFieldLooseBase(this, _db)[_db] = new DB(); // inits dummy data by default\n  }\n  testDummyData() {\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n  testAddCard() {\n    const question = \"What does the cat have?\";\n    const answer = \"A hat.\";\n    const new_card = {\n      \"question\": question,\n      \"answer\": answer\n    };\n    const deck_name = \"Deck 0\";\n    const chapter_name = \"Chapter 1\";\n    _classPrivateFieldLooseBase(this, _db)[_db].addCard(deck_name, chapter_name, new_card);\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n  testGetCard() {\n    const id = 0;\n    const deck_name = \"Deck 0\";\n    const chapter_name = \"Chapter 1\";\n    const card = _classPrivateFieldLooseBase(this, _db)[_db].getCard(deck_name, chapter_name, id);\n    console.log(card);\n  }\n  testEditCard() {\n    const id = 0;\n    const deck_name = \"Deck 0\";\n    const chapter_name = \"Chapter 1\";\n    const question = \"What the?\";\n    const answer = \"Oh, I understand.\";\n    console.log(_classPrivateFieldLooseBase(this, _db)[_db].getCard(deck_name, chapter_name, id));\n    _classPrivateFieldLooseBase(this, _db)[_db].editCard(deck_name, chapter_name, id, question, answer);\n    console.log(_classPrivateFieldLooseBase(this, _db)[_db].getCard(deck_name, chapter_name, id));\n  }\n  testAddChapter() {\n    const deck_name = \"Deck 0\";\n    // const new_chapter = \"Chapter 2\";\n    const new_chapter = \"Chapter 3\";\n    _classPrivateFieldLooseBase(this, _db)[_db].addChapter(deck_name, new_chapter);\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n  testAddDeck() {\n    // const deck_name = \"Deck 0\";\n    const deck_name = \"Deck 1\";\n    _classPrivateFieldLooseBase(this, _db)[_db].addDeck(deck_name);\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n  testFullAdd() {\n    const question = \"I hope this works?\";\n    const answer = \"It does!\";\n    const new_card = {\n      \"question\": question,\n      \"answer\": answer\n    };\n    const deck_name = \"Deck 1\";\n    const chapter_name = \"Chapter 1\";\n    _classPrivateFieldLooseBase(this, _db)[_db].addDeck(deck_name);\n    _classPrivateFieldLooseBase(this, _db)[_db].addChapter(deck_name, chapter_name);\n    _classPrivateFieldLooseBase(this, _db)[_db].addCard(deck_name, chapter_name, new_card);\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n}\n\n// if (require.main == module) {\n//     const test = new TestDB();\n//     // test.testDummyData();\n//     // test.testAddCard();\n//     // test.testGetCard();\n//     // test.testEditCard();\n//     // test.testAddChapter();\n//     // test.testAddDeck();\n//     // test.testFullAdd();\n// }","map":{"version":3,"names":["Deck","constructor","Object","defineProperty","_chapters","writable","value","_classPrivateFieldLooseBase","getChapterNames","names","name","_","entries","push","addChapter","chapter_name","hasChapter","new_chapter","Chapter","getChapter","undefined","getChapters","chapters_array","chapter","hasOwnProperty","printDeck","console","log","printCards","_cards","_classPrivateFieldLooseKey","id","size","addCard","question","answer","editCard","new_question","new_answer","getCard","i","length","_data","DB","dummy_data","initData","deck_name","addDeck","chapter_cards","getDeckNames","hasDeck","card","getCardIds","printDecks","deck","_db","TestDB","testDummyData","testAddCard","new_card","testGetCard","testEditCard","testAddChapter","testAddDeck","testFullAdd"],"sources":["C:/Users/clsno/OneDrive/Desktop/Learn React/Flashcards/src/database/database.js"],"sourcesContent":["class Deck {\r\n    #chapters;  // Chapters data\r\n\r\n    constructor() {\r\n        /**Class representation of a Deck.\r\n         * \r\n         * Functions:\r\n         * void addChapter(chapter_name)\r\n         * getChapter(chapter_name) -> Chapter()\r\n         * hasChapter(chapter_name) -> boolean\r\n         * getChapters() -> Array of Chapter objs\r\n         * void printDeck()\r\n         * getChapterNames() -> Array of strings\r\n         */\r\n        this.#chapters = {};\r\n    }\r\n\r\n    getChapterNames() {\r\n        /**Returns the names of all chapters within the deck.\r\n         * \r\n         * @returns Array of chapter name strings\r\n         */\r\n        let names = [];\r\n        for (const [name, _] of Object.entries(this.#chapters)) {\r\n            names.push(name);\r\n        }\r\n\r\n        return names;\r\n    }\r\n\r\n    addChapter(chapter_name) {\r\n        /**Adds a Chapter object with name (reference string) chapter_name to the Deck.\r\n         * \r\n         * @param {string} chapter_name - the name (reference string) of the new Chapter object\r\n         * @returns nothing\r\n         */\r\n        if (chapter_name != '' && !this.hasChapter(chapter_name)) {   // empty and existence check\r\n            const new_chapter = new Chapter();\r\n            this.#chapters[chapter_name] = new_chapter;\r\n        }\r\n    }\r\n\r\n    getChapter(chapter_name) {\r\n        /**Accessor for a Chapter object associated with 'chapter_name', within the Deck.\r\n         * \r\n         * @param {string} chapter_name - the name (reference string) of the desired Chapter object\r\n         * @returns Chapter object if found, undefined otherwise\r\n         */\r\n        if (chapter_name != '' && this.hasChapter(chapter_name)) {   // empty and existence check\r\n            return this.#chapters[chapter_name];\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    getChapters() {\r\n        /**Accessor for all chapters within a deck.\r\n         * \r\n         * @returns An array of chapter objects.\r\n         */\r\n        let chapters_array = [];\r\n        for (const chapter in this.#chapters) {\r\n            chapters_array.push(chapter);\r\n        }\r\n\r\n        return chapters_array;\r\n    }\r\n\r\n    hasChapter(chapter_name) {\r\n        /**Checks if the Deck has a Chapter with associated name (reference string) chapter_name.\r\n         * \r\n         * @param {string} chapter_name - the name (reference string) of the Chapter in question\r\n         * @returns boolean\r\n         */\r\n        return this.#chapters.hasOwnProperty(chapter_name);\r\n    }\r\n\r\n    printDeck() {\r\n        /**Prints the Deck for debugging.\r\n         * \r\n         */\r\n        console.log(\"__________\\nDeck:\")\r\n        for (const [_, chapter] of Object.entries(this.#chapters)) {\r\n            console.log(\"\\t\\tChapter:\")\r\n            chapter.printCards();\r\n        }\r\n    }\r\n}\r\n\r\nclass Chapter {\r\n    #cards; // Cards data\r\n\r\n    constructor() {\r\n        /**Class representation of a Chapter.\r\n         * \r\n         * Functions:\r\n         * void addCard(question, answer)\r\n         * void editCard(id, new_question, new_answer)\r\n         * getCard(id) -> object\r\n         * void printCards()\r\n         */\r\n        this.#cards = [];\r\n        this.id = 0;\r\n        this.size = 0;\r\n    }\r\n\r\n    addCard(question, answer) {\r\n        /**Adds an object representing a card with input args question and answer.\r\n         * The associated 'id' is handled internally.\r\n         * \r\n         * @param {string} question - the card question\r\n         * @param {string} answer - the card answer\r\n         * @returns nothing\r\n         */\r\n        // Remember to increment the id and size\r\n        this.#cards.push({id: this.id++,\"question\" : question, \"answer\" : answer});\r\n        this.size++;\r\n    }\r\n\r\n    editCard(id, new_question=undefined, new_answer=undefined) {\r\n        /**Edits the card object with id='id' to the new question and/or new answer.\r\n         * \r\n         * @param {int} id - id for the target card\r\n         * @param {string} question - new question\r\n         * @param {string} answer - new answer\r\n         */\r\n        if (id < this.id) { // ensure the card exists\r\n            // Edit question\r\n            if (new_question) {\r\n                this.#cards[id][\"question\"] = new_question;\r\n            }\r\n            // Edit answer\r\n            if (new_answer) {\r\n                this.#cards[id][\"answer\"] = new_answer;\r\n            }\r\n        }\r\n    }\r\n\r\n    getCard(id) {\r\n        /**Accessor for the associated card with id='id'.\r\n         * \r\n         * @param {int} id - associated id for the desired card\r\n         * @returns object\r\n         */\r\n        if (id < this.id) { // ensure the card exists\r\n            return this.#cards[id];\r\n        }\r\n    }\r\n\r\n    printCards() {\r\n        /**Prints the cards for debugging.\r\n         * \r\n         */\r\n        for (let i =0; i < this.#cards.length; i++) {\r\n            console.log(this.#cards[i]);\r\n        }\r\n    }\r\n}\r\n\r\nexport class DB {\r\n    #data;  // Flashcards data\r\n\r\n    constructor() {\r\n        /**Class representation of the database for the Flashcard App.\r\n         * \r\n         * Functions:\r\n         * void initData()\r\n         * void addCard(deck_name, chapter_name, card)\r\n         * void addChapter(deck_name, chapter_name)\r\n         * void addDeck(deck_name)\r\n         * hasDeck(deck_name) -> boolean\r\n         * hasChapter(deck_name, chapter_name) -> boolean\r\n         * getChapter(deck_name, chapter_name) -> Chapter obj\r\n         * void printDecks()\r\n         * getDeckNames() -> Array of strings\r\n         * getChapterNames(deck_name) -> Array of strings\r\n         * getCardIds(deck_name, chapter_name) -> Array of ints\r\n         */\r\n        this.dummy_data = {\r\n            \"Chapter 1\": \r\n            [\r\n              {question: \"What is a training instance?\", answer: \"One training iteration through all the data.\"},\r\n              {question: \"Why use machine learning?\", answer: \"To accomplish tasks infeasible for a human.\"},\r\n              {question: \"What is machine learning?\", answer: \"A computer being trained to improve at a task, by some performance measure.\"},\r\n            ],\r\n            \"Chapter 2\":\r\n            [    \r\n              {question: \"What is 2+2?\", answer: \"It's 4 silly!\"},\r\n              {question: \"What is the integral of x squared?\", answer: \"x to the third, all divided by 3... + C!\"},\r\n              {question: \"Cats or dogs?\", answer: \"Cats.\"},\r\n            ]\r\n        };\r\n        this.initData();\r\n    }\r\n\r\n    initData() {\r\n        /**Initializes the data based off some dummy data.\r\n         * \r\n         */\r\n        this.#data = {};\r\n        const deck_name = \"Deck 0\";\r\n        this.addDeck(deck_name); // add the deck\r\n        for (const [chapter_name, chapter_cards] of Object.entries(this.dummy_data)) {\r\n            this.addChapter(deck_name, chapter_name);\r\n            for (let i = 0; i < chapter_cards.length; i++) {\r\n                this.addCard(deck_name, chapter_name, chapter_cards[i]);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    getChapter(deck_name, chapter_name) {\r\n        /**Accessor for a chapter with name='chapter_name' in a deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck\r\n         * @param {string} chapter_name - Target chapter\r\n         * @return Chapter object\r\n         */\r\n        if (this.hasChapter(deck_name, chapter_name)) { // existence check\r\n            return this.#data[deck_name].getChapter(chapter_name);\r\n        }\r\n    }\r\n\r\n    getDeckNames() {\r\n        /**Returns the deck names for all decks in the database.\r\n         * \r\n         * @returns Array of strings\r\n         */\r\n        const names = [];\r\n        for (const [deck_name, _] of Object.entries(this.#data)) {\r\n            names.push(deck_name);\r\n        }\r\n\r\n        return names;\r\n    }\r\n\r\n    getChapterNames(deck_name) {\r\n        /**Returns the chapter names for a given deck.\r\n         * \r\n         * @param {string} deck_name - Target deck\r\n         * @returns Array of strings of chapter names\r\n         */\r\n        if (this.hasDeck(deck_name)) {  // existence check\r\n            return this.#data[deck_name].getChapterNames();\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    getChapters(deck_name) {\r\n        /**Accessor for chapters in a deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @return Array of chapter objects\r\n         */\r\n        if (this.hasDeck(deck_name)) {    // existence check\r\n            return this.#data[deck_name].getChapters();\r\n        }\r\n    }\r\n\r\n    addCard(deck_name, chapter_name, card) {\r\n        /**Adds a flashcard with values='card' to a chapter with name='chapter_name' to\r\n         * a deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - Target chapter name\r\n         * @param {object} card - New flashcard values\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name)) { // empty and existence checks\r\n                this.#data[deck_name].getChapter(chapter_name).addCard(card[\"question\"], card[\"answer\"]);\r\n        }\r\n    }\r\n\r\n    addChapter(deck_name, chapter_name) {\r\n        /**Adds a chapter with name='chapter_name' to a deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - New chapter name\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name) == false) { // empty and existence checks\r\n                // if the names aren't empty, the deck exists, and the chapter does not exist:\r\n                this.#data[deck_name].addChapter(chapter_name);\r\n        }\r\n    }\r\n\r\n    addDeck(deck_name) {\r\n        /**Adds a deck to the data with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - New deck name\r\n         */\r\n        if (deck_name != '' && !this.hasDeck(deck_name)) {  // empty and existence check\r\n            this.#data[deck_name] = new Deck();\r\n        }\r\n    }\r\n\r\n    hasDeck(deck_name) {\r\n        /**Checks if the data has the deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @returns boolean\r\n         */\r\n        return this.#data.hasOwnProperty(deck_name);\r\n    }\r\n\r\n    getCardIds(deck_name, chapter_name) {\r\n        /**Returns the IDs of cards in chapter 'chapter_name' in deck 'deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck\r\n         * @param {string} chapter_name - Target chapter\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name)) { // empty and existence checks\r\n                return this.#data[deck_name].getChapter(chapter_name).getCard(id);\r\n        }\r\n    }\r\n\r\n    hasChapter(deck_name, chapter_name) {\r\n        /**Checks if the data has the chapter with name='chapter_name' in deck\r\n         * with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - Target chapter name\r\n         * @returns boolean\r\n         */\r\n        if (this.hasDeck(deck_name)) {\r\n            return this.#data[deck_name].hasChapter(chapter_name);\r\n        }\r\n\r\n        return false;   // if the deck does not exist, return false\r\n    }\r\n\r\n    getCard(deck_name, chapter_name, id) {\r\n        /**Returns a flashcard with id='id' from a chapter with name='chapter_name' and\r\n         * deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - Target chapter name\r\n         * @param {int} card - Target card id\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name)) { // empty and existence checks\r\n                return this.#data[deck_name].getChapter(chapter_name).getCard(id);\r\n        }\r\n    }\r\n\r\n    editCard(deck_name, chapter_name, id, question, answer) {\r\n        /**Edits a flashcard with id='id' from a chapter with name='chapter_name' and\r\n         * deck with name='deck_name', with new values question='question and answer='answer'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - Target chapter name\r\n         * @param {int} card - Target card id\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name)) { // empty and existence checks\r\n                this.#data[deck_name].getChapter(chapter_name).editCard(id, question, answer);\r\n        }\r\n    }\r\n\r\n    printDecks() {\r\n        /**Prints each deck for debugging.\r\n         * \r\n         */\r\n        for (const [_, deck] of Object.entries(this.#data)) {\r\n            deck.printDeck();\r\n        }\r\n    }\r\n}\r\n\r\nclass TestDB {\r\n    /*Test Cases:\r\n    1. get a card's q/a\r\n    2. add a card\r\n    3. edit a card\r\n    4. add a chapter (dupe and unique chapter)\r\n    5. add a deck   (dupe and unique deck)\r\n    6. adding a new chapter and card to a new deck\r\n\r\n    Still need to test:\r\n    1. adding a card to a deck that doesn't exist\r\n    2. adding a card to a chapter that doesn't exist\r\n    3. editing a card that doesn't exist\r\n    */\r\n    #db;\r\n\r\n    constructor() {\r\n        /**Test class for the DB class.\r\n         * \r\n         */\r\n        this.#db = new DB();    // inits dummy data by default\r\n    }\r\n\r\n    testDummyData() {\r\n        this.#db.printDecks();\r\n    }\r\n\r\n    testAddCard() {\r\n        const question = \"What does the cat have?\"\r\n        const answer = \"A hat.\";\r\n        const new_card = {\"question\": question, \"answer\": answer};\r\n        const deck_name = \"Deck 0\";\r\n        const chapter_name = \"Chapter 1\";\r\n        this.#db.addCard(deck_name, chapter_name, new_card);\r\n        this.#db.printDecks();\r\n    }\r\n\r\n    testGetCard() {\r\n        const id = 0;\r\n        const deck_name = \"Deck 0\";\r\n        const chapter_name = \"Chapter 1\";\r\n        const card = this.#db.getCard(deck_name, chapter_name, id);\r\n        console.log(card);\r\n    }\r\n\r\n    testEditCard() {\r\n        const id = 0;\r\n        const deck_name = \"Deck 0\";\r\n        const chapter_name = \"Chapter 1\";\r\n        const question = \"What the?\";\r\n        const answer = \"Oh, I understand.\";\r\n\r\n        console.log(this.#db.getCard(deck_name, chapter_name, id));\r\n        this.#db.editCard(deck_name, chapter_name, id, question, answer);\r\n        console.log(this.#db.getCard(deck_name, chapter_name, id));\r\n    }\r\n\r\n    testAddChapter() {\r\n        const deck_name = \"Deck 0\";\r\n        // const new_chapter = \"Chapter 2\";\r\n        const new_chapter = \"Chapter 3\";\r\n        this.#db.addChapter(deck_name, new_chapter);\r\n        this.#db.printDecks();\r\n    }\r\n\r\n    testAddDeck() {\r\n        // const deck_name = \"Deck 0\";\r\n        const deck_name = \"Deck 1\";\r\n        this.#db.addDeck(deck_name);\r\n        this.#db.printDecks();\r\n    }\r\n\r\n    testFullAdd() {\r\n        const question = \"I hope this works?\"\r\n        const answer = \"It does!\";\r\n        const new_card = {\"question\": question, \"answer\": answer};\r\n        const deck_name = \"Deck 1\";\r\n        const chapter_name = \"Chapter 1\";\r\n\r\n        this.#db.addDeck(deck_name);\r\n        this.#db.addChapter(deck_name, chapter_name);\r\n        this.#db.addCard(deck_name, chapter_name, new_card);\r\n\r\n        this.#db.printDecks();\r\n    }\r\n}\r\n\r\n// if (require.main == module) {\r\n//     const test = new TestDB();\r\n//     // test.testDummyData();\r\n//     // test.testAddCard();\r\n//     // test.testGetCard();\r\n//     // test.testEditCard();\r\n//     // test.testAddChapter();\r\n//     // test.testAddDeck();\r\n//     // test.testFullAdd();\r\n// }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}