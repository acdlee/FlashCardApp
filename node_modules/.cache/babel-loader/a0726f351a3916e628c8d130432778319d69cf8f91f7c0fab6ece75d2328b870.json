{"ast":null,"code":"import _classPrivateFieldLooseBase from \"C:/Users/clsno/OneDrive/Desktop/Learn React/Flashcards/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js\";\nimport _classPrivateFieldLooseKey from \"C:/Users/clsno/OneDrive/Desktop/Learn React/Flashcards/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js\";\nvar _chapters = /*#__PURE__*/_classPrivateFieldLooseKey(\"chapters\");\nclass Deck {\n  // Chapters data\n\n  constructor() {\n    Object.defineProperty(this, _chapters, {\n      writable: true,\n      value: void 0\n    });\n    /**Class representation of a Deck.\r\n     * \r\n     * Functions:\r\n     * void addChapter(chapter_name)\r\n     * getChapter(chapter_name) -> Chapter()\r\n     * hasChapter(chapter_name) -> boolean\r\n     * getChapters() -> Array\r\n     * void printDeck()\r\n     */\n    _classPrivateFieldLooseBase(this, _chapters)[_chapters] = {};\n  }\n  addChapter(chapter_name) {\n    /**Adds a Chapter object with name (reference string) chapter_name to the Deck.\r\n     * \r\n     * @param {string} chapter_name - the name (reference string) of the new Chapter object\r\n     * @returns nothing\r\n     */\n    if (chapter_name != '' && !this.hasChapter(chapter_name)) {\n      // empty and existence check\n      const new_chapter = new Chapter();\n      _classPrivateFieldLooseBase(this, _chapters)[_chapters][chapter_name] = new_chapter;\n    }\n  }\n  getChapter(chapter_name) {\n    /**Accessor for a Chapter object associated with 'chapter_name', within the Deck.\r\n     * \r\n     * @param {string} chapter_name - the name (reference string) of the desired Chapter object\r\n     * @returns Chapter object if found, undefined otherwise\r\n     */\n    if (chapter_name != '' && this.hasChapter(chapter_name)) {\n      // empty and existence check\n      return _classPrivateFieldLooseBase(this, _chapters)[_chapters][chapter_name];\n    }\n    return undefined;\n  }\n  getChapters() {\n    /**Accessor for all chapters within a deck.\r\n     * \r\n     * @returns An array of chapter objects.\r\n     */\n    let chapters_array = [];\n    for (const chapter in _classPrivateFieldLooseBase(this, _chapters)[_chapters]) {\n      chapters_array.push(chapter);\n    }\n    return chapters_array;\n  }\n  hasChapter(chapter_name) {\n    /**Checks if the Deck has a Chapter with associated name (reference string) chapter_name.\r\n     * \r\n     * @param {string} chapter_name - the name (reference string) of the Chapter in question\r\n     * @returns boolean\r\n     */\n    return _classPrivateFieldLooseBase(this, _chapters)[_chapters].hasOwnProperty(chapter_name);\n  }\n  printDeck() {\n    /**Prints the Deck for debugging.\r\n     * \r\n     */\n    console.log(\"__________\\nDeck:\");\n    for (const [_, chapter] of Object.entries(_classPrivateFieldLooseBase(this, _chapters)[_chapters])) {\n      console.log(\"\\t\\tChapter:\");\n      chapter.printCards();\n    }\n  }\n}\nvar _cards = /*#__PURE__*/_classPrivateFieldLooseKey(\"cards\");\nclass Chapter {\n  // Cards data\n\n  constructor() {\n    Object.defineProperty(this, _cards, {\n      writable: true,\n      value: void 0\n    });\n    /**Class representation of a Chapter.\r\n     * \r\n     * Functions:\r\n     * void addCard(question, answer)\r\n     * void editCard(id, new_question, new_answer)\r\n     * getCard(id) -> object\r\n     * void printCards()\r\n     */\n    _classPrivateFieldLooseBase(this, _cards)[_cards] = [];\n    this.id = 0;\n  }\n  addCard(question, answer) {\n    /**Adds an object representing a card with input args question and answer.\r\n     * The associated 'id' is handled internally.\r\n     * \r\n     * @param {string} question - the card question\r\n     * @param {string} answer - the card answer\r\n     * @returns nothing\r\n     */\n    // Remember to increment the id\n    _classPrivateFieldLooseBase(this, _cards)[_cards].push({\n      id: this.id++,\n      \"question\": question,\n      \"answer\": answer\n    });\n  }\n  editCard(id, new_question = undefined, new_answer = undefined) {\n    /**Edits the card object with id='id' to the new question and/or new answer.\r\n     * \r\n     * @param {int} id - id for the target card\r\n     * @param {string} question - new question\r\n     * @param {string} answer - new answer\r\n     */\n    if (id < this.id) {\n      // ensure the card exists\n      // Edit question\n      if (new_question) {\n        _classPrivateFieldLooseBase(this, _cards)[_cards][id][\"question\"] = new_question;\n      }\n      // Edit answer\n      if (new_answer) {\n        _classPrivateFieldLooseBase(this, _cards)[_cards][id][\"answer\"] = new_answer;\n      }\n    }\n  }\n  getCard(id) {\n    /**Accessor for the associated card with id='id'.\r\n     * \r\n     * @param {int} id - associated id for the desired card\r\n     * @returns object\r\n     */\n    if (id < this.id) {\n      // ensure the card exists\n      return _classPrivateFieldLooseBase(this, _cards)[_cards][id];\n    }\n  }\n  printCards() {\n    /**Prints the cards for debugging.\r\n     * \r\n     */\n    for (let i = 0; i < _classPrivateFieldLooseBase(this, _cards)[_cards].length; i++) {\n      console.log(_classPrivateFieldLooseBase(this, _cards)[_cards][i]);\n    }\n  }\n}\nvar _data = /*#__PURE__*/_classPrivateFieldLooseKey(\"data\");\nexport class DB {\n  // Flashcards data\n\n  constructor() {\n    Object.defineProperty(this, _data, {\n      writable: true,\n      value: void 0\n    });\n    /**Class representation of the database for the Flashcard App.\r\n     * \r\n     * Functions:\r\n     * void initData()\r\n     * void addCard(deck_name, chapter_name, card)\r\n     * void addChapter(deck_name, chapter_name)\r\n     * void addDeck(deck_name)\r\n     * hasDeck(deck_name) -> boolean\r\n     * hasChapter(deck_name, chapter_name) -> boolean\r\n     * void printDecks()\r\n     */\n    this.dummy_data = {\n      \"Chapter 1\": [{\n        question: \"What is a training instance?\",\n        answer: \"One training iteration through all the data.\"\n      }, {\n        question: \"Why use machine learning?\",\n        answer: \"To accomplish tasks infeasible for a human.\"\n      }, {\n        question: \"What is machine learning?\",\n        answer: \"A computer being trained to improve at a task, by some performance measure.\"\n      }],\n      \"Chapter 2\": [{\n        question: \"What is 2+2?\",\n        answer: \"It's 4 silly!\"\n      }, {\n        question: \"What is the integral of x squared?\",\n        answer: \"x to the third, all divided by 3... + C!\"\n      }, {\n        question: \"Cats or dogs?\",\n        answer: \"Cats.\"\n      }]\n    };\n    this.initData();\n  }\n  initData() {\n    /**Initializes the data based off some dummy data.\r\n     * \r\n     */\n    _classPrivateFieldLooseBase(this, _data)[_data] = {};\n    const deck_name = \"Deck 0\";\n    this.addDeck(deck_name); // add the deck\n    for (const [chapter_name, chapter_cards] of Object.entries(this.dummy_data)) {\n      this.addChapter(deck_name, chapter_name);\n      for (let i = 0; i < chapter_cards.length; i++) {\n        this.addCard(deck_name, chapter_name, chapter_cards[i]);\n      }\n    }\n  }\n  getChapters(deck_name) {\n    /**Accessor for chapters in a deck.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @returns Array of chapter objects\r\n     */\n    if (this.hasDeck(deck_name)) {\n      // existence check\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapters();\n    }\n  }\n  addCard(deck_name, chapter_name, card) {\n    /**Adds a flashcard with values='card' to a chapter with name='chapter_name' to\r\n     * a deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - Target chapter name\r\n     * @param {object} card - New flashcard values\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name)) {\n      // empty and existence checks\n      _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapter(chapter_name).addCard(card[\"question\"], card[\"answer\"]);\n    }\n  }\n  addChapter(deck_name, chapter_name) {\n    /**Adds a chapter with name='chapter_name' to a deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - New chapter name\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name) == false) {\n      // empty and existence checks\n      // if the names aren't empty, the deck exists, and the chapter does not exist:\n      _classPrivateFieldLooseBase(this, _data)[_data][deck_name].addChapter(chapter_name);\n    }\n  }\n  addDeck(deck_name) {\n    /**Adds a deck to the data with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - New deck name\r\n     */\n    if (deck_name != '' && !this.hasDeck(deck_name)) {\n      // empty and existence check\n      _classPrivateFieldLooseBase(this, _data)[_data][deck_name] = new Deck();\n    }\n  }\n  hasDeck(deck_name) {\n    /**Checks if the data has the deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @returns boolean\r\n     */\n    return _classPrivateFieldLooseBase(this, _data)[_data].hasOwnProperty(deck_name);\n  }\n  hasChapter(deck_name, chapter_name) {\n    /**Checks if the data has the chapter with name='chapter_name' in deck\r\n     * with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - Target chapter name\r\n     * @returns boolean\r\n     */\n    if (this.hasDeck(deck_name)) {\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].hasChapter(chapter_name);\n    }\n    return false; // if the deck does not exist, return false\n  }\n  getCard(deck_name, chapter_name, id) {\n    /**Returns a flashcard with id='id' from a chapter with name='chapter_name' and\r\n     * deck with name='deck_name'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - Target chapter name\r\n     * @param {int} card - Target card id\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name)) {\n      // empty and existence checks\n      return _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapter(chapter_name).getCard(id);\n    }\n  }\n  editCard(deck_name, chapter_name, id, question, answer) {\n    /**Edits a flashcard with id='id' from a chapter with name='chapter_name' and\r\n     * deck with name='deck_name', with new values question='question and answer='answer'.\r\n     * \r\n     * @param {string} deck_name - Target deck name\r\n     * @param {string} chapter_name - Target chapter name\r\n     * @param {int} card - Target card id\r\n     */\n    if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name) && this.hasChapter(deck_name, chapter_name)) {\n      // empty and existence checks\n      _classPrivateFieldLooseBase(this, _data)[_data][deck_name].getChapter(chapter_name).editCard(id, question, answer);\n    }\n  }\n  printDecks() {\n    /**Prints each deck for debugging.\r\n     * \r\n     */\n    for (const [_, deck] of Object.entries(_classPrivateFieldLooseBase(this, _data)[_data])) {\n      deck.printDeck();\n    }\n  }\n}\nvar _db = /*#__PURE__*/_classPrivateFieldLooseKey(\"db\");\nclass TestDB {\n  constructor() {\n    /*Test Cases:\r\n    1. get a card's q/a\r\n    2. add a card\r\n    3. edit a card\r\n    4. add a chapter (dupe and unique chapter)\r\n    5. add a deck   (dupe and unique deck)\r\n    6. adding a new chapter and card to a new deck\r\n      Still need to test:\r\n    1. adding a card to a deck that doesn't exist\r\n    2. adding a card to a chapter that doesn't exist\r\n    3. editing a card that doesn't exist\r\n    */\n    Object.defineProperty(this, _db, {\n      writable: true,\n      value: void 0\n    });\n    /**Test class for the DB class.\r\n     * \r\n     */\n    _classPrivateFieldLooseBase(this, _db)[_db] = new DB(); // inits dummy data by default\n  }\n  testDummyData() {\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n  testAddCard() {\n    const question = \"What does the cat have?\";\n    const answer = \"A hat.\";\n    const new_card = {\n      \"question\": question,\n      \"answer\": answer\n    };\n    const deck_name = \"Deck 0\";\n    const chapter_name = \"Chapter 1\";\n    _classPrivateFieldLooseBase(this, _db)[_db].addCard(deck_name, chapter_name, new_card);\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n  testGetCard() {\n    const id = 0;\n    const deck_name = \"Deck 0\";\n    const chapter_name = \"Chapter 1\";\n    const card = _classPrivateFieldLooseBase(this, _db)[_db].getCard(deck_name, chapter_name, id);\n    console.log(card);\n  }\n  testEditCard() {\n    const id = 0;\n    const deck_name = \"Deck 0\";\n    const chapter_name = \"Chapter 1\";\n    const question = \"What the?\";\n    const answer = \"Oh, I understand.\";\n    console.log(_classPrivateFieldLooseBase(this, _db)[_db].getCard(deck_name, chapter_name, id));\n    _classPrivateFieldLooseBase(this, _db)[_db].editCard(deck_name, chapter_name, id, question, answer);\n    console.log(_classPrivateFieldLooseBase(this, _db)[_db].getCard(deck_name, chapter_name, id));\n  }\n  testAddChapter() {\n    const deck_name = \"Deck 0\";\n    // const new_chapter = \"Chapter 2\";\n    const new_chapter = \"Chapter 3\";\n    _classPrivateFieldLooseBase(this, _db)[_db].addChapter(deck_name, new_chapter);\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n  testAddDeck() {\n    // const deck_name = \"Deck 0\";\n    const deck_name = \"Deck 1\";\n    _classPrivateFieldLooseBase(this, _db)[_db].addDeck(deck_name);\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n  testFullAdd() {\n    const question = \"I hope this works?\";\n    const answer = \"It does!\";\n    const new_card = {\n      \"question\": question,\n      \"answer\": answer\n    };\n    const deck_name = \"Deck 1\";\n    const chapter_name = \"Chapter 1\";\n    _classPrivateFieldLooseBase(this, _db)[_db].addDeck(deck_name);\n    _classPrivateFieldLooseBase(this, _db)[_db].addChapter(deck_name, chapter_name);\n    _classPrivateFieldLooseBase(this, _db)[_db].addCard(deck_name, chapter_name, new_card);\n    _classPrivateFieldLooseBase(this, _db)[_db].printDecks();\n  }\n}\n\n// if (require.main == module) {\n//     const test = new TestDB();\n//     // test.testDummyData();\n//     // test.testAddCard();\n//     // test.testGetCard();\n//     // test.testEditCard();\n//     // test.testAddChapter();\n//     // test.testAddDeck();\n//     // test.testFullAdd();\n// }","map":{"version":3,"names":["Deck","constructor","Object","defineProperty","_chapters","writable","value","_classPrivateFieldLooseBase","addChapter","chapter_name","hasChapter","new_chapter","Chapter","getChapter","undefined","getChapters","chapters_array","chapter","push","hasOwnProperty","printDeck","console","log","_","entries","printCards","_cards","_classPrivateFieldLooseKey","id","addCard","question","answer","editCard","new_question","new_answer","getCard","i","length","_data","DB","dummy_data","initData","deck_name","addDeck","chapter_cards","hasDeck","card","printDecks","deck","_db","TestDB","testDummyData","testAddCard","new_card","testGetCard","testEditCard","testAddChapter","testAddDeck","testFullAdd"],"sources":["C:/Users/clsno/OneDrive/Desktop/Learn React/Flashcards/src/database/database.js"],"sourcesContent":["class Deck {\r\n    #chapters;  // Chapters data\r\n\r\n    constructor() {\r\n        /**Class representation of a Deck.\r\n         * \r\n         * Functions:\r\n         * void addChapter(chapter_name)\r\n         * getChapter(chapter_name) -> Chapter()\r\n         * hasChapter(chapter_name) -> boolean\r\n         * getChapters() -> Array\r\n         * void printDeck()\r\n         */\r\n        this.#chapters = {};\r\n    }\r\n\r\n    addChapter(chapter_name) {\r\n        /**Adds a Chapter object with name (reference string) chapter_name to the Deck.\r\n         * \r\n         * @param {string} chapter_name - the name (reference string) of the new Chapter object\r\n         * @returns nothing\r\n         */\r\n        if (chapter_name != '' && !this.hasChapter(chapter_name)) {   // empty and existence check\r\n            const new_chapter = new Chapter();\r\n            this.#chapters[chapter_name] = new_chapter;\r\n        }\r\n    }\r\n\r\n    getChapter(chapter_name) {\r\n        /**Accessor for a Chapter object associated with 'chapter_name', within the Deck.\r\n         * \r\n         * @param {string} chapter_name - the name (reference string) of the desired Chapter object\r\n         * @returns Chapter object if found, undefined otherwise\r\n         */\r\n        if (chapter_name != '' && this.hasChapter(chapter_name)) {   // empty and existence check\r\n            return this.#chapters[chapter_name];\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    getChapters() {\r\n        /**Accessor for all chapters within a deck.\r\n         * \r\n         * @returns An array of chapter objects.\r\n         */\r\n        let chapters_array = [];\r\n        for (const chapter in this.#chapters) {\r\n            chapters_array.push(chapter);\r\n        }\r\n\r\n        return chapters_array;\r\n    }\r\n\r\n    hasChapter(chapter_name) {\r\n        /**Checks if the Deck has a Chapter with associated name (reference string) chapter_name.\r\n         * \r\n         * @param {string} chapter_name - the name (reference string) of the Chapter in question\r\n         * @returns boolean\r\n         */\r\n        return this.#chapters.hasOwnProperty(chapter_name);\r\n    }\r\n\r\n    printDeck() {\r\n        /**Prints the Deck for debugging.\r\n         * \r\n         */\r\n        console.log(\"__________\\nDeck:\")\r\n        for (const [_, chapter] of Object.entries(this.#chapters)) {\r\n            console.log(\"\\t\\tChapter:\")\r\n            chapter.printCards();\r\n        }\r\n    }\r\n}\r\n\r\nclass Chapter {\r\n    #cards; // Cards data\r\n\r\n    constructor() {\r\n        /**Class representation of a Chapter.\r\n         * \r\n         * Functions:\r\n         * void addCard(question, answer)\r\n         * void editCard(id, new_question, new_answer)\r\n         * getCard(id) -> object\r\n         * void printCards()\r\n         */\r\n        this.#cards = [];\r\n        this.id = 0;\r\n    }\r\n\r\n    addCard(question, answer) {\r\n        /**Adds an object representing a card with input args question and answer.\r\n         * The associated 'id' is handled internally.\r\n         * \r\n         * @param {string} question - the card question\r\n         * @param {string} answer - the card answer\r\n         * @returns nothing\r\n         */\r\n        // Remember to increment the id\r\n        this.#cards.push({id: this.id++,\"question\" : question, \"answer\" : answer});\r\n    }\r\n\r\n    editCard(id, new_question=undefined, new_answer=undefined) {\r\n        /**Edits the card object with id='id' to the new question and/or new answer.\r\n         * \r\n         * @param {int} id - id for the target card\r\n         * @param {string} question - new question\r\n         * @param {string} answer - new answer\r\n         */\r\n        if (id < this.id) { // ensure the card exists\r\n            // Edit question\r\n            if (new_question) {\r\n                this.#cards[id][\"question\"] = new_question;\r\n            }\r\n            // Edit answer\r\n            if (new_answer) {\r\n                this.#cards[id][\"answer\"] = new_answer;\r\n            }\r\n        }\r\n    }\r\n\r\n    getCard(id) {\r\n        /**Accessor for the associated card with id='id'.\r\n         * \r\n         * @param {int} id - associated id for the desired card\r\n         * @returns object\r\n         */\r\n        if (id < this.id) { // ensure the card exists\r\n            return this.#cards[id];\r\n        }\r\n    }\r\n\r\n    printCards() {\r\n        /**Prints the cards for debugging.\r\n         * \r\n         */\r\n        for (let i =0; i < this.#cards.length; i++) {\r\n            console.log(this.#cards[i]);\r\n        }\r\n    }\r\n}\r\n\r\nexport class DB {\r\n    #data;  // Flashcards data\r\n\r\n    constructor() {\r\n        /**Class representation of the database for the Flashcard App.\r\n         * \r\n         * Functions:\r\n         * void initData()\r\n         * void addCard(deck_name, chapter_name, card)\r\n         * void addChapter(deck_name, chapter_name)\r\n         * void addDeck(deck_name)\r\n         * hasDeck(deck_name) -> boolean\r\n         * hasChapter(deck_name, chapter_name) -> boolean\r\n         * void printDecks()\r\n         */\r\n        this.dummy_data = {\r\n            \"Chapter 1\": \r\n            [\r\n              {question: \"What is a training instance?\", answer: \"One training iteration through all the data.\"},\r\n              {question: \"Why use machine learning?\", answer: \"To accomplish tasks infeasible for a human.\"},\r\n              {question: \"What is machine learning?\", answer: \"A computer being trained to improve at a task, by some performance measure.\"},\r\n            ],\r\n            \"Chapter 2\":\r\n            [    \r\n              {question: \"What is 2+2?\", answer: \"It's 4 silly!\"},\r\n              {question: \"What is the integral of x squared?\", answer: \"x to the third, all divided by 3... + C!\"},\r\n              {question: \"Cats or dogs?\", answer: \"Cats.\"},\r\n            ]\r\n        };\r\n        this.initData();\r\n    }\r\n\r\n    initData() {\r\n        /**Initializes the data based off some dummy data.\r\n         * \r\n         */\r\n        this.#data = {};\r\n        const deck_name = \"Deck 0\";\r\n        this.addDeck(deck_name); // add the deck\r\n        for (const [chapter_name, chapter_cards] of Object.entries(this.dummy_data)) {\r\n            this.addChapter(deck_name, chapter_name);\r\n            for (let i = 0; i < chapter_cards.length; i++) {\r\n                this.addCard(deck_name, chapter_name, chapter_cards[i]);\r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    getChapters(deck_name) {\r\n        /**Accessor for chapters in a deck.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @returns Array of chapter objects\r\n         */\r\n        if (this.hasDeck(deck_name)) {    // existence check\r\n            return this.#data[deck_name].getChapters();\r\n        }\r\n    }\r\n\r\n    addCard(deck_name, chapter_name, card) {\r\n        /**Adds a flashcard with values='card' to a chapter with name='chapter_name' to\r\n         * a deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - Target chapter name\r\n         * @param {object} card - New flashcard values\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name)) { // empty and existence checks\r\n                this.#data[deck_name].getChapter(chapter_name).addCard(card[\"question\"], card[\"answer\"]);\r\n        }\r\n    }\r\n\r\n    addChapter(deck_name, chapter_name) {\r\n        /**Adds a chapter with name='chapter_name' to a deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - New chapter name\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name) == false) { // empty and existence checks\r\n                // if the names aren't empty, the deck exists, and the chapter does not exist:\r\n                this.#data[deck_name].addChapter(chapter_name);\r\n        }\r\n    }\r\n\r\n    addDeck(deck_name) {\r\n        /**Adds a deck to the data with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - New deck name\r\n         */\r\n        if (deck_name != '' && !this.hasDeck(deck_name)) {  // empty and existence check\r\n            this.#data[deck_name] = new Deck();\r\n        }\r\n    }\r\n\r\n    hasDeck(deck_name) {\r\n        /**Checks if the data has the deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @returns boolean\r\n         */\r\n        return this.#data.hasOwnProperty(deck_name);\r\n    }\r\n\r\n    hasChapter(deck_name, chapter_name) {\r\n        /**Checks if the data has the chapter with name='chapter_name' in deck\r\n         * with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - Target chapter name\r\n         * @returns boolean\r\n         */\r\n        if (this.hasDeck(deck_name)) {\r\n            return this.#data[deck_name].hasChapter(chapter_name);\r\n        }\r\n\r\n        return false;   // if the deck does not exist, return false\r\n    }\r\n\r\n    getCard(deck_name, chapter_name, id) {\r\n        /**Returns a flashcard with id='id' from a chapter with name='chapter_name' and\r\n         * deck with name='deck_name'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - Target chapter name\r\n         * @param {int} card - Target card id\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name)) { // empty and existence checks\r\n                return this.#data[deck_name].getChapter(chapter_name).getCard(id);\r\n        }\r\n    }\r\n\r\n    editCard(deck_name, chapter_name, id, question, answer) {\r\n        /**Edits a flashcard with id='id' from a chapter with name='chapter_name' and\r\n         * deck with name='deck_name', with new values question='question and answer='answer'.\r\n         * \r\n         * @param {string} deck_name - Target deck name\r\n         * @param {string} chapter_name - Target chapter name\r\n         * @param {int} card - Target card id\r\n         */\r\n        if (deck_name != '' && chapter_name != '' && this.hasDeck(deck_name)\r\n            && this.hasChapter(deck_name, chapter_name)) { // empty and existence checks\r\n                this.#data[deck_name].getChapter(chapter_name).editCard(id, question, answer);\r\n        }\r\n    }\r\n\r\n    printDecks() {\r\n        /**Prints each deck for debugging.\r\n         * \r\n         */\r\n        for (const [_, deck] of Object.entries(this.#data)) {\r\n            deck.printDeck();\r\n        }\r\n    }\r\n}\r\n\r\nclass TestDB {\r\n    /*Test Cases:\r\n    1. get a card's q/a\r\n    2. add a card\r\n    3. edit a card\r\n    4. add a chapter (dupe and unique chapter)\r\n    5. add a deck   (dupe and unique deck)\r\n    6. adding a new chapter and card to a new deck\r\n\r\n    Still need to test:\r\n    1. adding a card to a deck that doesn't exist\r\n    2. adding a card to a chapter that doesn't exist\r\n    3. editing a card that doesn't exist\r\n    */\r\n    #db;\r\n\r\n    constructor() {\r\n        /**Test class for the DB class.\r\n         * \r\n         */\r\n        this.#db = new DB();    // inits dummy data by default\r\n    }\r\n\r\n    testDummyData() {\r\n        this.#db.printDecks();\r\n    }\r\n\r\n    testAddCard() {\r\n        const question = \"What does the cat have?\"\r\n        const answer = \"A hat.\";\r\n        const new_card = {\"question\": question, \"answer\": answer};\r\n        const deck_name = \"Deck 0\";\r\n        const chapter_name = \"Chapter 1\";\r\n        this.#db.addCard(deck_name, chapter_name, new_card);\r\n        this.#db.printDecks();\r\n    }\r\n\r\n    testGetCard() {\r\n        const id = 0;\r\n        const deck_name = \"Deck 0\";\r\n        const chapter_name = \"Chapter 1\";\r\n        const card = this.#db.getCard(deck_name, chapter_name, id);\r\n        console.log(card);\r\n    }\r\n\r\n    testEditCard() {\r\n        const id = 0;\r\n        const deck_name = \"Deck 0\";\r\n        const chapter_name = \"Chapter 1\";\r\n        const question = \"What the?\";\r\n        const answer = \"Oh, I understand.\";\r\n\r\n        console.log(this.#db.getCard(deck_name, chapter_name, id));\r\n        this.#db.editCard(deck_name, chapter_name, id, question, answer);\r\n        console.log(this.#db.getCard(deck_name, chapter_name, id));\r\n    }\r\n\r\n    testAddChapter() {\r\n        const deck_name = \"Deck 0\";\r\n        // const new_chapter = \"Chapter 2\";\r\n        const new_chapter = \"Chapter 3\";\r\n        this.#db.addChapter(deck_name, new_chapter);\r\n        this.#db.printDecks();\r\n    }\r\n\r\n    testAddDeck() {\r\n        // const deck_name = \"Deck 0\";\r\n        const deck_name = \"Deck 1\";\r\n        this.#db.addDeck(deck_name);\r\n        this.#db.printDecks();\r\n    }\r\n\r\n    testFullAdd() {\r\n        const question = \"I hope this works?\"\r\n        const answer = \"It does!\";\r\n        const new_card = {\"question\": question, \"answer\": answer};\r\n        const deck_name = \"Deck 1\";\r\n        const chapter_name = \"Chapter 1\";\r\n\r\n        this.#db.addDeck(deck_name);\r\n        this.#db.addChapter(deck_name, chapter_name);\r\n        this.#db.addCard(deck_name, chapter_name, new_card);\r\n\r\n        this.#db.printDecks();\r\n    }\r\n}\r\n\r\n// if (require.main == module) {\r\n//     const test = new TestDB();\r\n//     // test.testDummyData();\r\n//     // test.testAddCard();\r\n//     // test.testGetCard();\r\n//     // test.testEditCard();\r\n//     // test.testAddChapter();\r\n//     // test.testAddDeck();\r\n//     // test.testFullAdd();\r\n// }"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}